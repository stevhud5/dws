!==================================================================
!                    SHARED PARAMETER
!==================================================================

	MODULE SHARED

	SAVE

	REAL :: CLIST(10050,400),CONST,CREP,CFL,T(5000),G(5000),GF(5000)
	REAL :: tMIN,tMAX,TAGET_A(40),TAGET_TAO(40),PC,PM,Ls,d,MERR(2),G0
	REAL :: FQE(2000),GGE(2000),GGGE(2000),GGF(2000),GGGF(2000),FRLP
	REAL :: FQC1,GGC1,GGGC1,FQM,GGM,GGGM,FQC2,FQFC1,GGFC1,GGGFC1,FQFC2
	REAL :: FQFM,GGFM,GGGFM,LpMI,LpMA,APHMA,APHMI,RATIOMI,RATIOMA,ZEMI
	REAL ::	ZEMA,G0MA,G0MI,Kb,Vs,TEM,PHI,PI,RELAX,GERR(2),V0,t0,VERR
	REAL :: INDEX,BDIND,DT,RANG

	INTEGER :: LMAP(10050),LBREATH,SLP,NUM,NUMG,NUMIN,FLAGPR,FLAGD
	INTEGER :: NN,SAMPLE,GENERATION,NELT,TAGET_B(40),SERR(2),FLAGN
	INTEGER :: FLAGMR,II,FLAGIT,NIND 

	END MODULE SHARED
													   
!==================================================================
!				         MAIN PROGRAM START
!==================================================================

	PROGRAM MAIN

    USE SHARED
    IMPLICIT DOUBLE PRECISION (A-H,O-Z)

	REAL :: RATIOF,LpF,ZEF,APH,RATIO,Lp,ZE,FMI,FMA,PERR(5),FERR(4),G0F
	REAL :: MLIST1(400),MLIST2(400),MLIST3(400),GGG(5000),GG(5000),DW
	REAL :: REMAIN,BR,RND,G1,G2,ERRG,SUM,GGS,GGGS,GGC,GGGC,C1,C2,D0,W,La
	REAL :: tbr,trep,te,Le,ZETA,FIC,FIC2,TL,tp,LBAR,ST,OS,APHU,APHL,VOF
	REAL :: LENGTH(5050),WB,Li,EAPH,APH0,RATIO0,CLENTH,tMED,G21,G22,MARK
 
	INTEGER :: I,J,JJ,JJJ,K,KK,KKK,TT,N,M,LSEG,LENTH,SUM1,SUM2,INV,REM
	INTEGER :: FLAGC1,FLAGC2,FLAGH,FLAGF,FLAGIM,FLAGG,IDC1,IDM,IDH,LDR
	INTEGER :: LROUSE,LBEND,NUMOU,OUTF,OUTR,OUTW,IDATE(8),ISIZE,NLFU	
	INTEGER :: LBR,NEWL1,NEWL2,NEWL3,LPI(3),XCH,NM,Z,NLF,ITER
	INTEGER :: NLFL,FLAGSS
    INTEGER,ALLOCATABLE :: ISEED(:)

	CHARACTER :: TITLE,ANS1,ANS2,ANS3																										

!==================================================================
!				         INPUT PARAMETER
!==================================================================

 	Kb=1.381E-23                 ! BOLTZMANN CONSTANT
	PI=3.141592653   			 ! CONSTANT PI
	Vs=0.000891        		     ! SOLVENT VISCOSITY
    PHI=0.0662                   ! VOLUME FRACTION	
	TEM=298.15				     ! SYSTEMIC TEMPERATURE

    CALL DATE_AND_TIME(VALUES=IDATE)
    CALL RANDOM_SEED(SIZE=ISIZE)
    ALLOCATE(ISEED(ISIZE))
	ISEED=IDATE(2)+IDATE(3)+IDATE(4)
    ISEED=ISEED*(IDATE(6)+IDATE(5)+IDATE(7))
    CALL RANDOM_SEED(PUT=ISEED)

	APHMA=6.			         ! THE UPPPER BOUNDARY OF Le/Lp
	APHMI=0.5			         ! THE LOWER BOUNDARY OF Le/Lp
	RATIOMA=25.			     ! THE UPPPER BOUNDARY OF BREAKAGE RATE (ZETA)
	RATIOMI=10.**(-3.)           ! THE LOWER BOUNDARY OF BREAKAGE RATE (ZETA)
	LpMA=1.5*10**(-7.)		     ! THE UPPPER BOUNDARY OF Lp
	LpMI=1.5*10**(-8.)		     ! THE LOWER BOUNDARY OF Lp
	ZEMA=100.					 ! THE UPPPER BOUNDARY OF Z
	ZEMI=2.						 ! THE LOWER BOUNDARY OF Z

	DTL=10**(-6.)			     ! TIME STEP CONSTANT
	TT=10**8				     ! THE LARGEST NUMBER OF TIME STEP
 	NLFU=200			         ! MAXIMUM INCREASE OF MICELLE NUMBER
	NLFL=-200			         ! MAXIMUM DECREASE OF MICELLE NUMBER
	RANG=5.						 ! THE RANGE OF MICELLE LENGTH DISTRIBUTION
	Ls=0.2					     ! THE RATIO OF SEGMENTAL LENGTH TO Lp

	LBREATH=1					 ! THE SWITCHER FOR CLF
	LDR=1						 ! THE SWITCHER FOR DOUBLE REPTATION
	LROUSE=1					 ! THE SWITCHER FOR ROUSE MODES
	LBEND=1						 ! THE SWITCHER FOR BENDING	MODES
 	SLP=0						 ! THE SWITCHER FOR MODIFTING lp DURING ITERATIONS

	PC=0.5				         ! PROBABILITY OF PERMUTATION
	PM=0.1  	 		         ! PROBABILITY OF MUTATION
	GENERATION=20000 	         ! GENERATION NUMBER
	NN=20					   	 ! APPROXIMATE PARAMETER NUMBER
	SAMPLE=2*NN			         ! SAMPLE SIZE NUMBER 
	NELT=2						 ! ELITE SIZE

	JJJ=0						 ! TESTING NUMBER
	NUMOU=200					 ! NUMBER OF OUTPUT DATA 
 	INDEX=0.01 					 ! DATA RECORDING INTERVAL
    INV=5*10**5		  
	
	FLAGF=0				 	     ! FLAG FOR INCLUDING FREQUECNY INFORMATION				  
	FLAGMR=0					 ! FLAG FOR PURE MECHANICAL DATA

	OUTF=0						 ! THE SWITCHER FOR GENERATING FILE OF GT+GF
	OUTW=0						 ! THE SWITCHER FOR	GENERATING FILE OF GW
	OUTR=0						 ! THE SWITCHER FOR GENERATING FILE OF GW+ROUSE

	NUM=5000					 ! ENSEMBLE SIZE
	ITER=25						 ! ITERATIONS FOR PARAMETER FITTING
	FLAGIT=1					 ! ITERATIONS FOR CHANGING PLATEAU MODULUS
	RELAX=0.75
	REM=0

	FLAGC1=0					 ! FLAG FOR FINDING EXPERIMENTAL 1st CROSSOVER POINT
	FLAGIM=0			   		 ! FLAG FOR FINDING EXPERIMENTAL INTERMEDIATE POINT
	FLAGH=0						 ! FLAG FOR HIGH FREQUECNY EXPERIMENTAL DATA AVAILABLE
	FLAGC2=0					 ! FLAG FOR FINDING EXPERIMENTAL 2nd CROSSOVER POINT
	FLAGD=0					     ! FLAG FOR ENDING THE ITERATIONS AUTOMATICALLY
	FLAGG=0						 ! FLAG FOR FIXING TAO_I FOR GA
	FLAGN=0						 ! FLAG FOR INCREASING ENSEMBLE SIZE
	FLAGSS=0					 ! FLAG FOR STARTING SIMULATION FROM SPECIFIED PARAMETER VALUE

    OPEN(20,FILE='SIMULATION OUTPUT.DAT')	 ! PARAMETER AND FITTING ERROR EVOLUTION OUTPUT FILE
	OPEN(23,FILE='TIME_FREQUENCY TRANSFORMATION.DAT')	! MIU_I&TAO_I OUTPUT FILE 
	OPEN(24,FILE='SIMULATION MONITOR.DAT')  ! PROCESSION OF SIMULATION OUTPUT FILE

!==================================================================
!				         READING INPUT FILE
!==================================================================
											 
	OPEN(16,FILE='SAMPLE_INPUT1.DAT')	! EXPERIMENTAL DATA INPUT FILE
	READ(16,*) TITLE
	READ(16,*) TEM,PHI,Vs

	READ (16,*) ANS1,ANS2
	IF (ANS1.EQ.'Y') THEN
	FLAGF=1						 			          
	END IF
	IF (ANS2.EQ.'Y') THEN
	FLAGMR=1					 
	END IF

	READ(16,*) ANS1,ANS2,ANS3
	IF (ANS1.EQ.'Y') THEN
	OUTF=1
	END IF
 	IF (ANS2.EQ.'Y') THEN
	OUTW=1
	END IF
	IF (ANS3.EQ.'Y') THEN
	OUTR=1
	END IF

	READ(16,*) ANS1,Lp
	IF (ANS1.EQ.'Y') THEN
	SLP=1
	END IF

	READ(16,*) V0,Li,d
 	Li=Li*10**(-6.)			     ! AVERAGE MICELLE LENGTH
	Lp=Lp*10**(-9.)		         ! PERSISTENT LENGTH 
	d=d*10**(-9.)			     ! MICELLE DIAMETER

	READ(16,*) NUM,ITER
	READ(16,*) ANS1,RATIO0,APH0
 	IF (ANS1.EQ.'Y') THEN
	FLAGSS=1
	END IF

	NUMIN=0
	IF (FLAGF.EQ.1) THEN
    DO I=1,1000
	READ (16,*,END=10) FQE(I),GGE(I),GGGE(I)
	NUMIN=NUMIN+1
    END DO 
	END IF

10	CLOSE(16)
	WRITE(24,*) 'READ DATA FINISH'
	WRITE(*,*) 'READ DATA FINISH'

	IF (FLAGF.EQ.0)	THEN
	WRITE(24,*) 'ERROR: FREQUENCY INFORMATION NOT EXSIST'
	WRITE(*,*) 'ERROR: FREQUENCY INFORMATION NOT EXSIST'
	STOP
	END IF
   	IF (FLAGMR.EQ.1) THEN
	WRITE(24,*) 'WARNING: MECHANICAL RHEOMETRIC HIGH FREQUENCY DATA NEGLECTED'
	WRITE(*,*) 'WARNING: MECHANICAL RHEOMETRIC HIGH FREQUENCY DATA NEGLECTED'
	END IF

    WRITE(24,*) 'THE NUMBER OF DATA POINTS IS ',NUMIN 
    WRITE(*,*) 'THE NUMBER OF DATA POINTS IS ',NUMIN	  

!==================================================================
!	      FINDING EXPERIMENTAL LOCAL RHEOLOGICAL FEATURE 
!==================================================================

	FQC1=FQE(1)	            	 ! EXPERIMENTAL 1st CROSSOVER FREQUECNY 
	FQM=FQE(NUMIN)				 ! EXPERIMENTAL INTERMEDIATE FREQUECNY 
	GGC1=GGE(1)					 ! EXPERIMENTAL VALUE OF G' FOR 1st CROSSOVER  
	GGGC1=GGGE(1)				 ! EXPERIMENTAL VALUE OF G" FOR 1st CROSSOVER
	GGM=GGE(NUMIN)				 ! EXPERIMENTAL VALUE OF G' FOR INTERMEDIATE FREQUECNY 
	GGGM=GGGE(NUMIN)	    	 ! EXPERIMENTAL VALUE OF G" FOR INTERMEDIATE FREQUECNY

	IDC1=1						 ! INDEX OF DATA POINT FOR 1st CROSSOVER FREQUECNY
	IDM=NUMIN					 ! INDEX OF DATA POINT FOR INTERMEDIATE FREQUECNY
	IDH=NUMIN					 ! INDEX OF DATA POINT FOR REACHING HIGH FREQUECNY REQION

	DO J=2,NUMIN-1
	IF ((GGE(J-1).LE.GGGE(J-1)).AND.(GGE(J+1).GE.GGGE(J+1))) THEN	
	FQC1=FQE(J)
	IDC1=J
	GGC1=GGE(J)
	GGGC1=GGGE(J)
	FLAGC1=1
	EXIT
	END IF
	END DO

	IF (FLAGC1.EQ.1) THEN
	FQM=10*FQC1
	DO J=2,NUMIN-1
    IF ((FQE(J-1).LE.FQM).AND.(FQE(J+1).GE.FQM)) THEN
	IDM=J
 	GGM=GGE(J)
	GGGM=GGGE(J)
	FLAGIM=1
	EXIT
	END IF
	END DO
	END IF

	IF (FLAGIM.EQ.1) THEN
	DO J=2,NUMIN-1
    IF ((FQE(J-1).LE.20*FQM).AND.(FQE(J+1).GE.20*FQM)) THEN
	IDH=J
	FLAGH=1
	EXIT
	END IF
	END DO
	END IF

	IF (FLAGMR.EQ.0) THEN
	DO J=IDC1+2,NUMIN-1
	IF ((GGGE(J-1).LE.GGE(J-1)).AND.(GGGE(J+1).GE.GGE(J+1))) THEN
	FQC2=FQE(J)
	FLAGC2=1
	EXIT
	END IF
	END DO
	END IF

	IF (FLAGF.EQ.1)	THEN
	FMI=-2.            	                ! THE MINIMUM FREQUENCY OF EXPERIMENTAL DATA 
	FMA=5.                          	! THE MAXIMUM FREQUENCY OF EXPERIMENTAL DATA 
	DW=(FMA-FMI)/NUMOU			        ! INTERVAL OF FREQUENCY 
	END IF						 

   	IF ((FLAGC1.EQ.0).OR.(FLAGIM.EQ.0)) THEN
	WRITE(24,*) 'ERROR: BROADER FREQUENCY RANGE REQUIRED'
	WRITE(*,*) 'ERROR: BROADER FREQUENCY RANGE REQUIRED'
	STOP
	END IF
	IF (FLAGH.EQ.0)	THEN
	WRITE(24,*) 'WARNING: EXPERIMENT NOT REACH HIGH FREQUENCY ZONE'
	WRITE(24,*) 'INITIAL GUESS USED FOR PERSISTENCE LENGTH'
	WRITE(*,*) 'WARNING: EXPERIMENT NOT REACH HIGH FREQUENCY ZONE'
	WRITE(*,*) 'INITIAL GUESS USED FOR PERSISTENCE LENGTH'
	SLP=0
	END IF
	IF (FLAGC2.EQ.0) THEN
	WRITE(24,*) 'WARNING: 2nd CROSSOVER FREQUENCY NOT DETECTED'
	WRITE(24,*) 'ACCURACY OF PERSISTENCE LENGTH NOT GUARANTEED'
	WRITE(*,*) 'WARNING: 2nd CROSSOVER FREQUENCY NOT DETECTED'
	WRITE(*,*) 'ACCURACY OF PERSISTENCE LENGTH NOT GUARANTEED'
	END IF

!==================================================================
!				           INITIAL GUESSES
!==================================================================
																								
	G0MA=GGM*3.				     ! THE UPPPER BOUNDARY OF PLATEAU MODULUS
	G0MI=GGC1*2.			     ! THE LOWER BOUNDARY OF PLATEAU MODULUS

	C1=9.75*Kb*TEM/Lp**3./G0MA
	C2=3.*28./5./PI*Kb*TEM*PHI/d**2./G0MA/Lp
	APHL=1.
	DO I=1,50
	IF ((C1*APHL**2.2+C2-3.*APHL).LT.(APHMI**4.)) THEN
	APHL=APHMI
	ELSE
	APHL=(C1*APHL**2.2+C2-3.*APHL)**0.25
	END IF
	END DO
  	IF (APHL.GT.APHMI) THEN
	APHMI=APHL
	END IF

	C1=9.75*Kb*TEM/Lp**3./G0MI
	C2=3.*28./5./PI*Kb*TEM*PHI/d**2./G0MI/Lp
	APHU=1.
	DO I=1,50
	IF ((C1*APHU**2.2+C2-3.*APHU).GT.(APHMA**4.)) THEN
	APHU=APHMA
	ELSE
	APHU=(C1*APHU**2.2+C2-3.*APHU)**0.25
	END IF
	END DO
	IF (APHU.LT.APHMA) THEN
	APHMA=APHU
	END IF

	APH=2.						 ! RATIO OF Le TO Lp
	EAPH=10.
	K=0
Z01:DO WHILE ((EAPH.GT.10**3.).OR.(K.LT.10))

	EAPH=APH
	Le=APH*Lp       	         ! ENTANGLEMENT LENGTH 
	ZETA=Le**0.6*Lp**0.4         ! MESH SIZE
	FIC=2.*PI*Vs/LOG(ZETA/d)	 ! PARALLEL FRICTION COEFFICIENT 
	D0=Kb*TEM/FIC				 ! MOBILITY OF MICELLE
    TL=SQRT(APH/2.)	             ! RATIO OF MICELLE LENGTH TO TUBE LENGTH 
	IF (APH.LT.2) THEN
	TL=1.
	END IF

	ZE=Li/APH/Lp				 ! NUMBER OF ENTANGLEMENT
    La=Li/TL	    	         ! AVERAGE TUBE LENGTH
    trep=La**3./D0/PI**2.*TL	 ! REPTATION TIME
	RATIO=(APH**3./trep/FQC1)**1.5      ! RATIO OF BREAKAGE TO REPTATION TIME
 	G0=GGC1/(0.265-0.0657*LOG10(RATIO)) ! PLATEAU MODULUS
 	IF (G0.GT.G0MA) THEN
	G0=G0MA
	END IF
 	IF (G0.LT.G0MI) THEN
	G0=G0MI
	END IF

	C1=9.75*Kb*TEM/Lp**3./G0
	C2=3.*28./5./PI*Kb*TEM*PHI/d**2./G0/Lp						 
	DO I=1,50					  
	IF ((C1*APH**2.2+C2-3.*APH).GT.(APHU**4.)) THEN
	APH=APHU
	ELSE
 	IF ((C1*APH**2.2+C2-3.*APH).LT.(APHL**4.)) THEN
	APH=APHL
	ELSE
	APH=(C1*APH**2.2+C2-3.*APH)**0.25
	END IF
	END IF
	END DO

	EAPH=ABS(EAPH-APH)/APH	   ! CORRECTION OF ALPHA
	K=K+1
	END DO Z01

!==================================================================
!				      ITERATION PART
!==================================================================

	JJ=1
	II=1
	SERR(1)=10.
	SERR(2)=10.
	MERR(1)=10.
	MERR(2)=10.

Z00:DO WHILE (JJ.LE.ITER)	! ITERATION STARTS				 			
	FLAGPR=0		! FLAG FOR OVER-WRITING PARAMETER & OUTPUT FILE			        

	C1=9.75*Kb*TEM/Lp**3./G0
	C2=3.*28./5./PI*Kb*TEM*PHI/d**2./G0/Lp
	APH=2.						 ! INTIAL GUESS FOR RATIO OF Le TO Lp
	DO I=1,50					  
	IF ((C1*APH**2.2+C2-3.*APH).GT.(APHMA**4.)) THEN
	APH=APHMA
	ELSE
 	IF ((C1*APH**2.2+C2-3.*APH).LT.(APHMI**4.)) THEN
	APH=APHMI
	ELSE
	APH=(C1*APH**2.2+C2-3.*APH)**0.25
	END IF
	END IF
	END DO	 

	IF ((FLAGSS.EQ.1).AND.(JJ.EQ.1).AND.(II.EQ.1)) THEN
	APH=APH0
	RATIO=RATIO0
	ZE=Li/APH/Lp
	C1=9.75*Kb*TEM/Lp**3./APH**1.8
	C2=28./5./PI*Kb*TEM*PHI/d**2./APH/Lp
	G0=(C1*APH**3.+C2*3.)/(3.+APH**3.)
	END IF

    TL=SQRT(APH/2.)	        ! RATIO OF MICELLE LENGTH TO TUBE LENGTH 
	IF (APH.LT.2) THEN
	TL=1.
	END IF 
    La=ZE*Lp*APH/TL		    ! AVERAGE TUBE LENGTH     
	Le=APH*Lp    	        ! ENTANGLEMENT LENGTH 

	ZETA=Le**0.6*Lp**0.4         ! MESH SIZE
	LBAR=La/Lp			         ! RATIO OF TUBE LENGTH TO Lp
	FIC=2.*PI*Vs/LOG(ZETA/d)	 ! PARALLEL FRICTION COEFFICIENT 
	D0=Kb*TEM/FIC				 ! MOBILITY OF MICELLE
    trep=La**3./D0/PI**2.*TL	 ! REPTATION TIME	
	tbr=RATIO*trep				 ! BREAKAGE TIME
	te=Le**3./(TL*PI)**2./D0
    FIC2=4.*PI*Vs/LOG(0.6*ZETA/d)  ! PERPENDICULAR FRICTION COEFFICIENT
	tp=2*Lp**(5./3.)*FIC2/Kb/TEM   ! BENDING TIME
	ST=0.3827*Kb*TEM*tp**0.75/15./PI*4.*d**(-2.)*PHI ! BENDING MODES COEFFICIENT FOR G'
	OS=0.9239/0.3827*ST          ! BENDING MODES COEFFICIENT FOR G"

	IF (JJ.EQ.ITER) THEN
	GOTO  42
	END IF
	
	IF (JJ.GT.10) THEN
	FLAGN=1
	END IF

	IF (FLAGN.EQ.1) THEN
	NUM=5000
    ELSE 
	NUM=2500
	END IF

	WRITE(20,*) 'ITERATION: ',JJ,II
    WRITE(20,*) 'PLATEAU:',G0
    WRITE(20,*) 'RATIO:',RATIO
	WRITE(20,*)	'Trep:',trep
	WRITE(20,*)	'Ze:',ZE   
	WRITE(20,*) 'MICELLE LENGTH:',La*TL
    WRITE(20,*) 'ALPHA:',APH
    WRITE(20,*) 'PERSISTENCE:',Lp
    WRITE(20,*) 'DIAMETER:',d

	WRITE(*,*) 'ITERATION: ',JJ,II
    WRITE(*,*) 'PLATEAU:',G0
    WRITE(*,*) 'RATIO:',RATIO
	WRITE(*,*)	'Trep:',trep
	WRITE(*,*)	'Ze:',ZE
    WRITE(*,*) 'MICELLE LENGTH:',La*TL
    WRITE(*,*) 'ALPHA:',APH
    WRITE(*,*) 'PERSISTENCE:',Lp
    WRITE(*,*) 'DIAMETER:',d

!==================================================================
!			  DISCRITIZE MICELLE LENGTH DISTRIBUTION
!==================================================================

	DT=tbr/NUM/2.
	IF (DT.GT.DTL) THEN
	DT=DTL
	END IF
	MARK=tbr/DT/NUM/2.	

	N=1							 ! INTERVAL OF DISCRETIZED MICELLE TUBE LENGTH
	Ls=EXP(RANG)/NUM*LBAR
	M=CEILING(RANG*LBAR/Ls)	     ! MAXIMUM LENGTH IN THE ENSEMBLE
  	DO J=1,10000
  	SUM1=0
    DO I=1,M				     ! GENERATE MICELLE FOLLOWED BY ITS LENGTH DISTRIBUTION
    SUM1=SUM1+CEILING(NUM*N*Ls*EXP(-1.*I*N*Ls/LBAR)/LBAR)
	END DO
	REMAIN=SUM1-NUM	
    IF (ABS(REMAIN).EQ.0) THEN	 		 
	EXIT
	ELSE
	Ls=Ls/NUM*SUM1
    M=CEILING(RANG*LBAR/Ls)
    END IF			
	END DO

21  WRITE(24,*) 'LINEAR LENGTH DISCRETIZATION FINISH'
	WRITE(*,*) 'LINEAR LENGTH DISCRETIZATION FINISH'

	WRITE(24,*) 'THE MINIMUM TUBE LENGTH IS',Lp*N*Ls
	WRITE(24,*) 'THE MAXIMUM TUBE LENGTH IS',M*N*Lp*Ls
	WRITE(*,*) 'THE MINIMUM TUBE LENGTH IS',Lp*N*Ls
	WRITE(*,*) 'THE MAXIMUM TUBE LENGTH IS',M*N*Lp*Ls

	SUM2=0.
	LSEG=0
A00:DO I=1,M	
	LENGTH(I)=CEILING(NUM*N*Ls*EXP(-1.*I*N*Ls/LBAR)/LBAR)
	IF ((I.EQ.M).AND.(SUM2+LENGTH(I).NE.NUM)) THEN
	LENGTH(I)=NUM-SUM2
	END IF

	SUM1=1+SUM2
    SUM2=SUM2+LENGTH(I)
	LSEG=LSEG+I*N*LENGTH(I)
	DO J=SUM1,SUM2
 	LMAP(J)=I*N			
	CLIST(J,1)=1.
	CLIST(J,2)=0.
	CLIST(J,3)=LMAP(J)
	END DO
	END DO A00
	WRITE(24,*) 'CHAIN LIST INITIATION FINISH'
	WRITE(*,*) 'CHAIN LIST INITIATION FINISH'

!==================================================================
!	       LOW FREQUENCY SIMULATION FOR ENTANGLED MICELLES
!==================================================================

	KKK=1
	NLF=0

	CREP=2.*D0*DT/(Lp*Ls)**3./TL
	CONST=2.*(CREP*TL/3./PI/Ls)**0.25
	CFL=4.*CREP*TL/3./PI/Ls

!    GOTO 999

A01:DO K=1,TT					 ! EVOLUTION OF ENSEMBLE DUE TO RELAXATION AND BREAKAGE 
    OPEN(21,FILE='TEMP.DAT')

	IF (K.EQ.1) THEN
	KK=0
	END IF

	DO I=1,NUM+NLF
	LENTH=2*INT(CLIST(I,1))+1
	DO J=1,LENTH				 
	MLIST1(J)=CLIST(I,J)
	END DO
	NEWL1=LMAP(I)
	CALL MPDR(MLIST1,NEWL1,MLIST2)	
	LENTH=2*INT(MLIST2(1))+1
	DO J=1,LENTH
	CLIST(I,J)=MLIST2(J)
	END DO
	END DO

	IF (MOD(K,INV).EQ.0) THEN
	WRITE(24,*) K,'REPTATION FINISH'
	WRITE(*,*) K,'REPTATION FINISH'
	END IF

B01:IF (K.GT.MARK*KK) THEN		! BREAKAGE AND REJOINING OCCURS
	KK=KK+1  	 
    CALL RANDOM_NUMBER(BR)		! BREAKAGE 
		
C01:IF ((BR.LT.0.5D0).OR.(NLF.LE.NLFL)) THEN
31  CALL RANDOM_NUMBER(RND)
	LBR=INT(RND*LSEG)
	IF (LBR.LT.1) THEN
	GOTO 31
	END IF
	DO I=1,NUM+NLF
	LBR=LBR-LMAP(I)
	IF (LBR.EQ.0) THEN
	GOTO 31
	END IF			
	IF (LBR.LT.0) THEN
	LBR=LBR+LMAP(I)
	LPI(1)=I
	EXIT
	END IF
	END DO

	NEWL1=LMAP(LPI(1))
	LENTH=2*INT(CLIST(LPI(1),1))+1
 	DO I=1,LENTH				 
	MLIST1(I)=CLIST(LPI(1),I)
	END DO
	CALL BRKG(LBR,MLIST1,NEWL1,MLIST2,NEWL2,MLIST3,NEWL3)

	LMAP(LPI(1))=NEWL2
	LENTH=2*INT(MLIST2(1))+1
	DO I=1,LENTH
	CLIST(LPI(1),I)=MLIST2(I)
	END DO
	LMAP(NUM+NLF+1)=NEWL3
	LENTH=2*INT(MLIST3(1))+1
	DO I=1,LENTH
	CLIST(NUM+NLF+1,I)=MLIST3(I)
	END DO

	IF (MOD(K,INV).EQ.0) THEN
	WRITE(24,*) 'CHAIN BREAKAGE OCCUR:',K
	WRITE(*,*) 'CHAIN BREAKAGE OCCUR:',K
	END IF
	NLF=NLF+1

	END IF C01

C02:IF ((BR.GT.0.5D0).OR.(NLF.GE.NLFU)) THEN	! REJOINING
32  CALL RANDOM_NUMBER(RND)
	LPI(1)=INT(RND*(NUM+NLF))
	IF (LPI(1).LT.1) THEN
	GOTO 32
	END IF
33  CALL RANDOM_NUMBER(RND)
	LPI(2)=INT(RND*(NUM+NLF))
	IF (LPI(2).LT.1) THEN
	GOTO 33
	END IF

	IF (LPI(2).EQ.LPI(1)) THEN
	GOTO 32
	END IF
	IF ((LMAP(LPI(1))+LMAP(LPI(2))).GT.M*N) THEN
    GOTO 32
	END IF

	NEWL1=LMAP(LPI(1))
	LENTH=2*INT(CLIST(LPI(1),1))+1
	DO I=1,LENTH
	MLIST1(I)=CLIST(LPI(1),I)
	END DO
	NEWL2=LMAP(LPI(2))
 	LENTH=2*INT(CLIST(LPI(2),1))+1
	DO I=1,LENTH
	MLIST2(I)=CLIST(LPI(2),I)
	END DO
    CALL REJN(MLIST1,NEWL1,MLIST2,NEWL2,MLIST3,NEWL3)

	LMAP(LPI(1))=NEWL3
	LENTH=2*INT(MLIST3(1))+1
	DO I=1,LENTH
	CLIST(LPI(1),I)=MLIST3(I)
	END DO

	DO I=LPI(2),NUM+NLF-1
	LMAP(I)=LMAP(I+1)
	LENTH=2*INT(CLIST(I+1,1))+1
	DO J=1,LENTH
	CLIST(I,J)=CLIST(I+1,J)
	END DO
	END DO		
		
    IF (MOD(K,INV).EQ.0) THEN
	WRITE(24,*) 'CHAIN RECOMBATION OCCUR:',K
	WRITE(*,*) 'CHAIN RECOMBATION OCCUR:',K
	END IF
	NLF=NLF-1

	END IF C02

	END IF B01

	IF (K.EQ.3) THEN
	NUMG=1
	END	IF

	G21=G2					   ! CALCULATE STRESS RELAXATION FUNCTION
	G1=0.
	DO I=1,NUM+NLF
	IF (INT(CLIST(I,1)).GT.0) THEN
	DO J=1,INT(CLIST(I,1))
	G1=G1+(CLIST(I,2*J+1)-CLIST(I,2*J))/LSEG
	END DO
	END IF
	END DO
	IF (LDR.EQ.1) THEN
	G2=G1**2.
	ELSE
	G2=G1
	END IF
	G22=G2

	IF (K.GE.3)	THEN
	CALL GGT(K,G21,G22)				! PICK APPROPRIATE NUMBER OF THE DATA FROM TEMPORARY FILE
	END IF

	IF (MOD(K,INV).EQ.0) THEN
	WRITE(24,*) K,NLF,G2
	WRITE(*,*) K,NLF,G2
	END IF

	IF (G2.LT.0.001) THEN
	REM=K
	WRITE(21,*)	-1,K*DT,G2
	WRITE(*,*) 'REM',K
	WRITE(24,*)	'REM',K
	CLOSE(21)
	EXIT
	END IF

	END DO A01

! 999     REM=134600
	NUMG=NUMG-1
    WRITE(*,*) 'INITIATION OF GA FINISHED'
	WRITE(24,*) 'INITIATION OF GA FINISHED'

!==================================================================
!				TIME TO FREQUENCY TRANSFORMATION
!==================================================================

	tMAX=LOG10(T(NUMG))-0.5
	tMIN=LOG10(T(1))+0.5
	tMED=3*(tMAX-tMIN+0.5)

	NN=INT(tMED)+MOD(INT(tMED),2)
	CALL GEAM(FLAGG,TAGET_A,TAGET_B,TAGET_TAO,ERRG)

	WRITE(23,*)	'ITERATION: ',JJ,II
	DO I=1,NN
	WRITE(23,*) TAGET_A(I)*10.**TAGET_B(I),TAGET_TAO(I)
	WRITE(*,*) TAGET_A(I)*10.**TAGET_B(I),TAGET_TAO(I)
	END DO

    WRITE(23,*) 'GA ERROR IS',ERRG
    WRITE(24,*) 'GA ERROR IS',ERRG
    WRITE(*,*) 'GA ERROR IS',ERRG

	WRITE(24,*) 'RELAXATION TIME CALCULATION FINISH'
	WRITE(*,*) 'RELAXATION TIME CALCULATION FINISH'

	IF (OUTF.EQ.1) THEN
 	OPEN(7,FILE='GF_t.DAT')	  ! WRITE OUTPUT FILE FOR FITTED G(t) GENERATE BY GA
    WRITE(7,*) 'ITERATION: ',JJ,II	 
 	WRITE(7,*) 'PARAMETERS PART'
 	WRITE(7,*) 'RATIO',RATIO
 	WRITE(7,*) 'TIME INTERVAL',DT	
 	WRITE(7,*) 'MICELLE LENGTH',LBAR*TL 	
    WRITE(7,*) 'PLATAEU',G0
 	WRITE(7,*) 'Le',Le 
    WRITE(7,*) 'Lp',Lp    
 	WRITE(7,*) 'DATA PART'
    DO I=1,NUMG
	WRITE(7,*) T(I),G(I),GF(I)
    END DO
	CLOSE(7)
	END IF

	t0=0.
	DO I=1,NN
	t0=t0+TAGET_A(I)*10.**TAGET_B(I)*TAGET_TAO(I)
	END DO
    VERR=LOG(t0*G0/V0)

 	DO I=1,NUMOU		  ! GENERATE SIMULATED G'&G" FOR LOW FREQUENCY
	W=10**(FMI+DW*I)
	GG(I)=0.
	GGG(I)=0.
	DO J=1,NN
	SUM=TAGET_A(J)*10.**(TAGET_B(J))
	GG(I)=GG(I)+SUM*(W*TAGET_TAO(J))**2./(1.+(W*TAGET_TAO(J))**2.)
	GGG(I)=GGG(I)+SUM*(W*TAGET_TAO(J))/(1.+(W*TAGET_TAO(J))**2.)
	END DO
	END DO

	DO I=1,NUMIN
	GGF(I)=0.
	GGGF(I)=0.
	DO J=1,NN
	SUM=TAGET_A(J)*10.**(TAGET_B(J))
	GGF(I)=GGF(I)+SUM*(FQE(I)*TAGET_TAO(J))**2./(1.+(FQE(I)*TAGET_TAO(J))**2.)
	GGGF(I)=GGGF(I)+SUM*(FQE(I)*TAGET_TAO(J))/(1.+(FQE(I)*TAGET_TAO(J))**2.)
	END DO
	END DO

	IF (OUTW.EQ.1)	THEN
	OPEN(12,FILE='GW.DAT')	   ! WRITE OUTPUT FILE FOR NORMALIZED LOW FREQUENCY G'&G"
    WRITE(12,*) 'ITERATION: ',JJ,II   
	WRITE(12,*) 'PARAMETERS PART'
	WRITE(12,*) 'RATIO',RATIO
	WRITE(12,*) 'TIME INTERVAL',DT	
	WRITE(12,*) 'MICELLE LENGTH',LBAR*TL 	
    WRITE(12,*) 'PLATAEU',G0
	WRITE(12,*) 'Le',Le 
    WRITE(12,*) 'Lp',Lp    
	WRITE(12,*) 'DATA PART'
    DO I=1,NUMOU
	WRITE(12,*) 10**(FMI+DW*I),GG(I),GGG(I)
    END DO
	CLOSE(12)
	END IF

!==================================================================
!				    HIGH FREQUENCY SIMULATION
!==================================================================

A02:IF (LROUSE.EQ.1) THEN  ! ROUSE MODES
	DO I=1,NUMOU
	W=10**(FMI+DW*I)
	GGS=0.
    GGGS=0.

	DO J=1,M
	Z=CEILING(J*N*Ls*TL/APH)
	NM=CEILING(J*N*Ls*TL/2.)
	IF (Z.GE.1) THEN
 	VOF=LENGTH(J)/NUM*J*N*Ls/LBAR
	ELSE
	CYCLE
	END IF
	GGC=0.
	GGGC=0.
	DO K=Z,NM
	GGC=GGC+1./(4.*(K/Z)**4+(W*te)**2)
	GGGC=GGGC+2.*(K/Z)**2/(4.*(K/Z)**4+(W*te)**2)
	END DO
	GGC=GGC*5./4.*(W*te)**2*VOF/Z
	GGGC=GGGC*5./4.*W*te*VOF/Z
	GGS=GGS+GGC
	GGGS=GGGS+GGGC
	END DO

	GG(I)=GG(I)+GGS
	GGG(I)=GGG(I)+GGGS
	END DO

	DO I=1,NUMIN
	GGS=0.
    GGGS=0.

	DO J=1,M
	Z=CEILING(J*N*Ls*TL/APH)
	NM=CEILING(J*N*Ls*TL/2.)
	IF (Z.GE.1) THEN
 	VOF=LENGTH(J)/NUM*J*N*Ls/LBAR
	ELSE
	CYCLE
	END IF
	GGC=0.
	GGGC=0.
	DO K=Z,NM
	GGC=GGC+1./(4.*(K/Z)**4+(FQE(I)*te)**2)
	GGGC=GGGC+2.*(K/Z)**2/(4.*(K/Z)**4+(FQE(I)*te)**2)
	END DO
	GGC=GGC*5./4.*(FQE(I)*te)**2*VOF/Z
	GGGC=GGGC*5./4.*FQE(I)*te*VOF/Z
	GGS=GGS+GGC
	GGGS=GGGS+GGGC
	END DO

	GGF(I)=GGF(I)+GGS
	GGGF(I)=GGGF(I)+GGGS
	END DO

	WRITE(24,*) 'ROUSE MODES INCLUDE'
	WRITE(*,*) 'ROUSE MODES INCLUDE'
	END IF A02

	IF (OUTR.EQ.1) THEN
	OPEN(9,FILE='ROUSE.DAT')  ! WRITE OUTPUT FILE FOR NORMALIZED G'&G" WITH HIGH FREQUENCY ROUSE MODES
	WRITE(9,*) 'ITERATION: ',JJ,II
	WRITE(9,*) 'PARAMETERS PART'
	WRITE(9,*) 'RATIO',RATIO
	WRITE(9,*) 'TIME INTERVAL',DT	
	WRITE(9,*) 'MICELLE LENGTH',LBAR*TL 	
    WRITE(9,*)  'PLATAEU',G0 
    WRITE(9,*)  'Le',Le 
    WRITE(9,*)  'Lp',Lp 
 	WRITE(9,*)	'DATA PART'
    DO I=1,NUMOU
 	WRITE(9,*) 10**(FMI+DW*I),GG(I),GGG(I)
    END DO
 	CLOSE(9)
	END IF

	IF (LBEND.EQ.1) THEN	! BENDING MODES
	DO I=1,NUMOU
	W=10**(FMI+DW*I)
	GG(I)=GG(I)*G0
    GGG(I)=GGG(I)*G0
	DO J=1,M
	CLENTH=J*N*Ls*TL
	WB=W*(CLENTH/APH)**2.*te
	WB=WB**2./(1.+WB**2.)
	VOF=LENGTH(J)/NUM*CLENTH/TL/LBAR        
	GG(I)=GG(I)+VOF*(ST*W**0.75)*WB
	GGG(I)=GGG(I)+VOF*(OS*W**0.75+W*Vs)*WB
	END DO
	END DO

	DO I=1,NUMIN
	GGF(I)=GGF(I)*G0
    GGGF(I)=GGGF(I)*G0
	DO J=1,M
	CLENTH=J*N*Ls*TL
	WB=FQE(I)*(CLENTH/APH)**2.*te
	WB=WB**2./(1.+WB**2.)
	VOF=LENGTH(J)/NUM*CLENTH/TL/LBAR
	GGF(I)=GGF(I)+VOF*(ST*FQE(I)**0.75)*WB
	GGGF(I)=GGGF(I)+VOF*(OS*FQE(I)**0.75+FQE(I)*Vs)*WB
	END DO
	END DO

	WRITE(24,*) 'BENDING MODES INCLUDE'
	WRITE(*,*) 'BENDING MODES INCLUDE'
    END IF

	WRITE(24,*) JJ,II,'LOOP FINISH'
	WRITE(24,*) 'REM',REM
	WRITE(*,*) JJ,II,'LOOP FINISH'
	WRITE(*,*) 'REM',REM

!==================================================================
!			 FINDING SIUMLATED LOCAL RHEOLOGICAL FEATURE
!==================================================================

 	FQFC1=10**(FMI+DW)	         ! SIMULATED 1st CROSSOVER FREQUECNY 
	FQFM=10**(FMI+DW*NUMOU)		 ! SIMULATED INTERMEDIATE FREQUECNY 
	GGFC1=GG(1)					 ! SIMULATED VALUE OF G' FOR 1st CROSSOVER  
	GGGFC1=GGG(1)				 ! SIMULATED VALUE OF G" FOR 1st CROSSOVER
	GGFM=GG(NUMOU)				 ! SIMULATED VALUE OF G' FOR INTERMEDIATE FREQUECNY 
	GGGFM=GGG(NUMOU)	    	 ! SIMULATED VALUE OF G" FOR INTERMEDIATE FREQUECNY

	DO J=2,NUMOU-1
	IF ((GG(J-1).LE.GGG(J-1)).AND.(GG(J+1).GE.GGG(J+1))) THEN	
	FQFC1=10**(FMI+DW*J)
	GGFC1=GG(J)
	GGGFC1=GGG(J)
	XCH=J
	EXIT
	END IF
	END DO

	FQFM=10*FQFC1
	DO J=2,NUMOU-1
 	SUM=10**(FMI+DW*J)
    IF ((SUM/10**DW.LE.FQFM).AND.(SUM*10**DW.GE.FQFM)) THEN
 	GGFM=GG(J)
	GGGFM=GGG(J)
	EXIT
	END IF
	END DO

	IF (FLAGMR.EQ.0) THEN
	DO J=XCH+2,NUMOU-1
	IF ((GGG(J-1).LE.GG(J-1)).AND.(GGG(J+1).GE.GG(J+1))) THEN
	FQFC2=10**(FMI+DW*J)
	EXIT
	END IF
	END DO
	END IF

!==================================================================
!			CALCULATING FITTING ERRORS AND DIFFERENCE
!==================================================================				

	CALL CFER(IDC1,IDM,IDH,FERR,PERR)
	IF (FLAGMR.EQ.1) THEN
	FRLP=0.5*FERR(3)
	END IF

	WRITE(20,*) 'FERROR1:',FERR(1)
	WRITE(20,*) 'FERROR2:',FERR(2)
	WRITE(20,*) 'FERROR3:',FERR(3)
	WRITE(20,*) 'FERROR4:',FERR(4)
	
	IF (FLAGN.EQ.0) THEN
	WRITE(20,*) 'VERROR:',VERR
	ELSE
	WRITE(20,*) '*VERROR:',VERR	
	END IF
	
	WRITE(20,*) 'PERROR1:',PERR(1)
	WRITE(20,*) 'PERROR2:',PERR(2)
 	WRITE(20,*) 'PERROR3:',PERR(3)
	WRITE(20,*) 'PERROR4:',PERR(4)
	WRITE(20,*) 'PERROR5:',PERR(5)

	WRITE(*,*) 'FERROR1:',FERR(1)
	WRITE(*,*) 'FERROR2:',FERR(2)
	WRITE(*,*) 'FERROR3:',FERR(3)
	WRITE(*,*) 'FERROR4:',FERR(4)

	IF (FLAGN.EQ.0) THEN
	WRITE(*,*) 'VERROR:',VERR
	ELSE
	WRITE(*,*) '*VERROR:',VERR	
	END IF

	WRITE(*,*) 'PERROR1:',PERR(1)
	WRITE(*,*) 'PERROR2:',PERR(2)
 	WRITE(*,*) 'PERROR3:',PERR(3)
	WRITE(*,*) 'PERROR4:',PERR(4)
	WRITE(*,*) 'PERROR5:',PERR(5)
				   
!   IF (FLAGPR.EQ.1) THEN
	OPEN(10,FILE='RESULT1.DAT')	! OUTPUT FILE WITH MINIMUM FITTING ERROR
    WRITE(10,*) 'ITERATION: ',JJ,II
	WRITE(10,*) 'PARAMETERS PART'
	WRITE(10,*) 'RATIO',RATIO
	WRITE(10,*) 'TIME INTERVAL',DT
	WRITE(10,*)	'REPTATION TIME',trep
 	WRITE(10,*)	'BREAKAGE TIME',trep*RATIO
	WRITE(10,*) 'MICELLE LENGTH',LBAR*TL*Lp
	WRITE(10,*) 'PLATAEU',G0	
    WRITE(10,*) 'Le',Le 
    WRITE(10,*) 'Lp',Lp  
    WRITE(10,*) 'd',d 	  
	WRITE(10,*) 'DATA PART'
    DO I=1,NUMOU
	WRITE(10,*) 10**(FMI+DW*I),GG(I),GGG(I)
    END DO
	CLOSE(10)
!	END IF

	IF (FLAGD.EQ.1) THEN
	WRITE(*,*) JJ,II,' ITERATION SUCCEED'
	WRITE(24,*) JJ,II,' ITERATION SUCCEED'
	WRITE(20,*) 'THE RESULT CONVERGED HERE'
	GOTO 42
	END IF

!==================================================================
!		    	OPTIMIZATION OF MICELLE PARAMETERS
!==================================================================

 	RATIOF=RATIO
	ZEF=ZE
	LpF=Lp
	G0F=G0

A03:IF (JJ.LT.ITER) THEN	
  	CALL PRDF(G0F,RATIOF,ZEF,LpF,G0,RATIO,ZE,Lp,FLAGIT)	

	IF (FLAGIT.EQ.0) THEN
	II=1
	JJ=JJ+1
	FLAGIT=1
	END IF

	WRITE(20,*) 'G0:',G0
	WRITE(*,*) 'G0:',G0
	WRITE(20,*) 'RATIO:',RATIO
	WRITE(*,*) 'RATIO:',RATIO
	WRITE(20,*) 'Ze:',ZE
	WRITE(*,*) 'Ze:',ZE
	WRITE(20,*) 'Lp:',Lp
	WRITE(*,*) 'Lp:',Lp
	END IF A03	 

	WRITE(*,*) 'GOTO NEXT LOOP'
	WRITE(24,*) 'GOTO NEXT LOOP'

!	GOTO 99

	END DO Z00


!==================================================================
!		    	FINAL RESULT OF FITTING PARAMETERS
!==================================================================


42  IF ((FLAGD.EQ.1).OR.(JJ.EQ.ITER)) THEN
	WRITE(*,*) 'FINAL RESULT:'
	WRITE(*,*) 'ITERATION: ',JJ,II
	WRITE(*,*) 'PLATAEU:',G0
	WRITE(*,*) 'RATIO:',RATIO	
	WRITE(*,*) 'MICELLE LENGTH:',LBAR*TL*Lp	
    WRITE(*,*) 'Le:',Le 
    WRITE(*,*) 'Lp:',Lp 
	WRITE(*,*) 'd:',d

	WRITE(20,*) 'FINAL RESULT:'
	WRITE(20,*) 'ITERATION: ',JJ,II
	WRITE(20,*) 'PLATAEU:',G0
	WRITE(20,*) 'RATIO:',RATIO	
	WRITE(20,*) 'MICELLE LENGTH:',LBAR*TL*Lp	
    WRITE(20,*) 'Le:',Le 
    WRITE(20,*) 'Lp:',Lp 
	WRITE(20,*) 'd:',d	
	END IF   

99  CLOSE(20)
	CLOSE(23)
	CLOSE(24)
!	close(10)

    STOP

    END	PROGRAM MAIN


!==================================================================
!                          END HERE
!==================================================================









































!==================================================================
!      SUBROUTINE 1: MOVEMENT OF POINTERS DUE TO RELAXATION
!==================================================================

	SUBROUTINE MPDR(CLISTi1,LMAPi1,CLISTo1)

	USE SHARED

	REAL :: DL1,DL2(2),FL(2),RNDs1
    REAL, INTENT(IN) ::	CLISTi1(400)
    REAL, INTENT(OUT) :: CLISTo1(400)
	INTEGER :: Is1,Js1,ITERs1,LENTHs1,NUMPs1
	INTEGER, INTENT(IN) :: LMAPi1

	ITERs1=20
	DO Is1=1,2*INT(CLISTi1(1))+1 ! THE POSTION OF POINTERS 
	CLISTo1(Is1)=CLISTi1(Is1)
	END DO				 				 

S01:IF (CLISTo1(1).GT.0) THEN	 
	LENTHs1=2*INT(CLISTo1(1))+1

    IF (LBREATH.EQ.1) THEN		 ! CLFS
	FL(1)=CLISTo1(2)
    FL(2)=LMAPi1-CLISTo1(LENTHs1)
	DO Is1=1,2
	IF (FL(Is1).LE.0.2) THEN
	DL2(Is1)=CONST
	ELSE
	DL2(Is1)=FL(Is1)
	DO Js1=1,ITERs1
	DL2(Is1)=CFL/(FL(Is1)+DL2(Is1)/2.)**3.
	END DO
	END IF		 
	END DO
	CLISTo1(2)=CLISTo1(2)+DL2(1)
	CLISTo1(LENTHs1)=CLISTo1(LENTHs1)-DL2(2)
	END IF 

	IF (CLISTo1(2).GT.CLISTo1(3)) THEN
	DO Is1=2,INT(CLISTo1(1))
	CLISTo1(2*Is1-2)=CLISTo1(2*Is1)
	CLISTo1(2*Is1-1)=CLISTo1(2*Is1+1)
	END DO
	CLISTo1(1)=CLISTo1(1)-1
	END IF

	IF (CLISTo1(LENTHs1-1).GT.CLISTo1(LENTHs1)) THEN
	CLISTo1(1)=CLISTo1(1)-1
	END IF
	END IF S01

	DL1=SQRT(CREP/LMAPi1)
	CALL RANDOM_NUMBER(RNDs1)
S02:IF (CLISTo1(1).GT.0) THEN
    IF (RNDs1.LT.0.5) THEN		 ! REPATATION

	NUMPs1=0
	DO Is1=2,2*INT(CLISTo1(1))+1 
	IF (CLISTo1(Is1)+DL1.LE.LMAPi1) THEN
	CLISTo1(Is1)=CLISTo1(Is1)+DL1
	NUMPs1=NUMPs1+1
	END IF
	END DO
	IF (MOD(NUMPs1,2).NE.0) THEN
	LENTHs1=NUMPs1+2
	CLISTo1(LENTHs1)=LMAPi1
	CLISTo1(1)=(NUMPs1+1)/2
	ELSE
	CLISTo1(1)=NUMPs1/2
	END IF

	ELSE
	NUMPs1=0
	DO Is1=2,2*INT(CLISTo1(1))+1 
	IF (CLISTo1(Is1)-DL1.GE.0.) THEN
	CLISTo1(Is1)=CLISTo1(Is1)-DL1
	NUMPs1=NUMPs1+1
	END IF
	END DO
	IF (MOD(NUMPs1,2).NE.0) THEN
	CLISTo1(2)=0.
	LENTHs1=2*INT(CLISTo1(1))-NUMPs1
	DO Is1=LENTHs1+2,2*INT(CLISTo1(1))+1
	CLISTo1(Is1-LENTHs1+1)=CLISTo1(Is1)
	END DO
	CLISTo1(1)=(NUMPs1+1)/2
	ELSE
	LENTHs1=2*INT(CLISTo1(1))-NUMPs1
	DO Is1=LENTHs1+2,2*INT(CLISTo1(1))+1
	CLISTo1(Is1-LENTHs1)=CLISTo1(Is1)
	END DO
	CLISTo1(1)=NUMPs1/2
	END IF

	END IF
	END IF S02

S03:DO Is1=1,INT(CLISTo1(1))		  ! ANNILATION OF POINTERS
	IF (CLISTo1(1).GT.0) THEN

	IF (CLISTo1(2*Is1).GT.CLISTo1(2*Is1+1)) THEN
    DO Js1=Is1,INT(CLISTo1(1)-1)
	CLISTo1(2*Js1)=CLISTo1(2*(Js1+1))
	CLISTo1(2*Js1+1)=CLISTo1(2*(Js1+1)+1)
	END DO
	CLISTo1(1)=CLISTo1(1)-1
	END IF

	IF ((CLISTo1(2*Is1+1).GT.CLISTo1(2*Is1+2)).AND.(Is1.LT.CLISTo1(1))) THEN
    DO Js1=Is1,INT(CLISTo1(1)-2)
	CLISTo1(2*Js1+1)=CLISTo1(2*(Js1+1)+1)
	CLISTo1(2*Js1+2)=CLISTo1(2*(Js1+1)+2)
	END DO
	LENTHs1=2*INT(CLISTo1(1))+1
	CLISTo1(LENTHs1-2)=CLISTo1(LENTHs1)
	CLISTo1(1)=CLISTo1(1)-1
	END IF

	END IF
	END DO S03

	RETURN

	END SUBROUTINE MPDR

!==================================================================
!      SUBROUTINE 2: BREAKAGE
!==================================================================

	SUBROUTINE BRKG(NUMi2,CLISTi2,LMAPi2,CLIST1o2,LMAP1o2,CLIST2o2&
	&,LMAP2o2)

	USE SHARED

    REAL, INTENT(IN) ::	CLISTi2(400)
    REAL, INTENT(OUT) :: CLIST1o2(400),CLIST2o2(400)
	INTEGER :: Is2,LENTHs2,NUMP1s2,NUMP2s2,FLAGs2
	INTEGER, INTENT(IN) :: NUMi2,LMAPi2
	INTEGER, INTENT(OUT) :: LMAP1o2,LMAP2o2

	LMAP1o2=NUMi2
	LMAP2o2=LMAPi2-NUMi2

	IF (CLISTi2(1).EQ.0) THEN
	CLIST1o2(1)=0
	CLIST2o2(1)=0
	END IF

S04:IF (CLISTi2(1).GT.0) THEN

	NUMP1s2=0
	LENTHs2=2*INT(CLISTi2(1))+1
	DO Is2=2,LENTHs2
	IF (CLISTi2(Is2).LE.NUMi2) THEN
	NUMP1s2=NUMP1s2+1
	END IF
	END DO

	DO Is2=2,NUMP1s2+1
	CLIST1o2(Is2)=CLISTi2(Is2)
	END DO

	IF (MOD(NUMP1s2,2).NE.0) THEN
	CLIST1o2(NUMP1s2+2)=LMAP1o2
	CLIST1o2(1)=(NUMP1s2+1)/2
	ELSE
	CLIST1o2(1)=NUMP1s2/2
	END IF

	NUMP2s2=2*INT(CLISTi2(1))-NUMP1s2
	IF (MOD(NUMP2s2,2).NE.0) THEN
	CLIST2o2(2)=0.
	CLIST2o2(1)=(NUMP2s2+1)/2
	FLAGs2=1
	ELSE
	CLIST2o2(1)=NUMP2s2/2
	FLAGs2=0
	END IF

 	DO Is2=NUMP1s2+2,LENTHs2
 	CLIST2o2(Is2-NUMP1s2+FLAGs2)=CLISTi2(Is2)-NUMi2
	END DO

	END IF S04

	RETURN

	END SUBROUTINE BRKG

!==================================================================
!      SUBROUTINE 3: REJOINING
!==================================================================

	SUBROUTINE REJN(CLIST1i3,LMAP1i3,CLIST2i3,LMAP2i3,CLISTo3,LMAPo3)

	USE SHARED

    REAL, INTENT(IN) :: CLIST1i3(400),CLIST2i3(400)
    REAL, INTENT(OUT) :: CLISTo3(400)
	INTEGER :: Is3,LENTH1s3,LENTH2s3
 	INTEGER, INTENT(IN) :: LMAP1i3,LMAP2i3
	INTEGER, INTENT(OUT) :: LMAPo3

	LMAPo3=LMAP1i3+LMAP2i3
	CLISTo3(1)=CLIST1i3(1)+CLIST2i3(1)

 	LENTH1s3=2*INT(CLIST1i3(1))+1
	IF (CLIST1i3(1).GT.0) THEN	
	DO Is3=2,LENTH1s3
	CLISTo3(Is3)=CLIST1i3(Is3)
	END DO
	ELSE
	END IF

 	LENTH2s3=2*INT(CLIST2i3(1))+1
	IF (CLIST2i3(1).GT.0) THEN	
	DO Is3=2,LENTH2s3
	CLISTo3(LENTH1s3+Is3-1)=CLIST2i3(Is3)+LMAP1i3
	END DO
	END IF	

	RETURN

	END SUBROUTINE REJN

!==================================================================
!      SUBROUTINE 4: GENERATE G(t) 
!==================================================================

	SUBROUTINE GGT(Ni4,G1i4,G2i4)
 
	USE SHARED

    REAL, INTENT(IN) :: G1i4,G2i4
	INTEGER :: FLAGs4
	INTEGER, INTENT(IN)	:: Ni4

S05:IF (G2i4.GT.SQRT(0.1)) THEN
	FLAGs4=0
    IF (Ni4.EQ.3) THEN
	BDIND=3.*DT
	NIND=0
	ELSE
	IF (FLOOR(LOG10(Ni4*DT)).EQ.CEILING(LOG10((Ni4-1)*DT)))	THEN
	BDIND=Ni4*DT
	NIND=0
	END IF
	END IF
	
	ELSE
	FLAGs4=1
	IF (G1i4.GT.SQRT(0.1)) THEN 	
	BDIND=G2i4
	NIND=0
	ELSE
 	IF (FLOOR(LOG10(G2i4)).EQ.CEILING(LOG10(G1i4))) THEN
	BDIND=G2i4
	NIND=0
	END IF
	END IF
	END IF S05

	IF (FLAGs4.EQ.0) THEN				 ! WRITTING TIME DOMAIN DATA IN THE TEMPORARY FILE
	IF (Ni4*DT.GE.BDIND*10.**(INDEX*NIND)) THEN	
	WRITE(21,*)	Ni4,Ni4*DT,G2i4
	NIND=NIND+1
	T(NUMG)=Ni4*DT
	G(NUMG)=G2i4
	NUMG=NUMG+1
	END IF
	ELSE
 	IF (G2i4.LE.BDIND/10.**(INDEX*NIND)) THEN	
	WRITE(21,*)	Ni4,Ni4*DT,G2i4
	NIND=NIND+1
	T(NUMG)=Ni4*DT
	G(NUMG)=G2i4
	NUMG=NUMG+1
	END IF
	END IF 

	RETURN 

	END	SUBROUTINE GGT
  
!==================================================================
!      SUBROUTINE 5: GENETIC ALGORITHM 
!==================================================================

	SUBROUTINE GEAM(FLAGi5,Ao5,Bo5,To5,ERRMo5)

 	USE SHARED

	REAL :: RNDs5,A(60,40),IND1s5,IND2s5,TAO(60,40),OPT1,OPT2,R3s5
	REAL :: RSUM1s5,ERR(60),MINs5,XCHCs5,R1s5,RSUM2s5,R2s5,RSUM3s5
	REAL, INTENT(OUT) :: Ao5(40),To5(40),ERRMo5
	INTEGER :: Is5,Js5,Ks5,IIs5,RESCALE1,RESCALE2,CHECK,POINT
	INTEGER :: XCHs5,Ms5,PT1,PT2,B(60,40),Ds5,JJs5
	INTEGER, INTENT(IN) :: FLAGi5
	INTEGER, INTENT(OUT) :: Bo5(40)

	DO Is5=1,SAMPLE			  ! GENERATE RANDOM ENSEMBLE FOR GA FITTING PARAMETERS
	DO Js5=1,NN      
	CALL RANDOM_NUMBER(RNDs5)
	A(Is5,Js5)=RNDs5*9.+1.
	CALL RANDOM_NUMBER(RNDs5)
	B(Is5,Js5)=FLOOR((RNDs5-1.)*3.)
	IF ((Js5.EQ.NN).OR.(Js5.EQ.1)) THEN
	B(Is5,Js5)=-2
	END IF
	IND1s5=(tMAX-tMIN)/NN*(Js5-1)+tMIN
	IND2s5=(tMAX-tMIN)/NN*Js5+tMIN
	IF (FLAGi5.EQ.0) THEN
	CALL RANDOM_NUMBER(RNDs5)
	TAO(Is5,Js5)=10.**((IND2s5-IND1s5)*RNDs5+IND1s5)
	ELSE
	TAO(Is5,Js5)=10.**((tMAX-tMIN)/NN*(Js5-0.5)+tMIN) 
	END IF
	END DO
	END DO

	OPT1=10.**4.

S06:DO Ks5=1,GENERATION 	! EVOLUATION OF THE FITTING ENSEMBLE 

S07:DO Is5=1,SAMPLE			! NORMALIZE THE FITTING ENSEMBLE 
	RESCALE1=1
	RESCALE2=1
	CHECK=1

	JJs5=0

S12:DO WHILE ((CHECK+RESCALE1+RESCALE2).NE.0)

	JJs5=JJs5+1

	CALL RANDOM_NUMBER(RNDs5)
	POINT=CEILING(RNDs5*(NN-1))

	B(Is5,1)=MAX(B(Is5,1),-3)
	B(Is5,1)=MIN(B(Is5,1),-1)
	B(Is5,NN)=MAX(B(Is5,NN),-3)
	B(Is5,NN)=MIN(B(Is5,NN),-1)

	DO Js5=1,POINT-1
	Ds5=ABS(B(Is5,Js5+1)-B(Is5,Js5))
	IF (Ds5.GT.1) THEN
	RESCALE1=1
	CALL RANDOM_NUMBER(RNDs5)
	Ds5=NINT(RNDs5*2.5-1.25)
	B(Is5,Js5+1)=Ds5+B(Is5,Js5)
        B(Is5,Js5+1)=MAX(B(Is5,Js5+1),-3)
        B(Is5,Js5+1)=MIN(B(Is5,Js5+1),-1)
	END IF
	END DO
	DO Js5=1,NN-POINT
    Ds5=ABS(B(Is5,NN+1-Js5)-B(Is5,NN-Js5))
	IF (ABS(Ds5).GT.1) THEN
	RESCALE1=1
	CALL RANDOM_NUMBER(RNDs5)
	Ds5=NINT(RNDs5*2.5-1.25)
	B(Is5,NN-Js5)=Ds5+B(Is5,NN+1-Js5)
	B(Is5,NN-Js5)=MAX(B(Is5,NN-Js5),-3)
	B(Is5,NN-Js5)=MIN(B(Is5,NN-Js5),-1)
	END IF
	END DO
	CHECK=0		

	RSUM1s5=0.
	DO Js5=1,NN
	R1s5=LOG10(T(1)/TAO(Is5,Js5))
	IF ((R1s5.GT.-3.).AND.(R1s5.LT.2.)) THEN
    RSUM1s5=RSUM1s5+A(Is5,Js5)*10.**B(Is5,Js5)/&
	&EXP(T(1)/TAO(Is5,Js5))
	ELSE
	IF (R1s5.LE.-3.) THEN
 	RSUM1s5=RSUM1s5+A(Is5,Js5)*10.**B(Is5,Js5)
	END IF
	END IF
	END DO
	IF (ABS(RSUM1s5-G(1)).LT.10.**(-4.)) THEN
	GOTO 02
	ELSE
	RESCALE2=1
	END IF
	DO Js5=1,NN
	A(Is5,Js5)=A(Is5,Js5)/RSUM1s5*G(1)
	DO WHILE (A(Is5,Js5).LT.1.)
	CHECK=1
	A(Is5,Js5)=10.*A(Is5,Js5)
	B(Is5,Js5)=B(Is5,Js5)-1
	END DO
	DO WHILE (A(Is5,Js5).GE.10.)
	CHECK=1
	A(Is5,Js5)=A(Is5,Js5)/10.
	B(Is5,Js5)=B(Is5,Js5)+1
	END DO
	END DO
02	RESCALE1=0 

	RSUM1s5=0.
	RSUM2s5=0.
	RSUM3s5=0.
    DO Js5=1,NN
	R1s5=A(Is5,Js5)*10.**B(Is5,Js5)
	RSUM3s5=RSUM3s5+R1s5/EXP(T(1)/TAO(Is5,Js5))
	IF (T(NUMG)/TAO(Is5,Js5).LT.10.) THEN
	RSUM1s5=RSUM1s5+R1s5/EXP(T(NUMG)/TAO(Is5,Js5))
	RSUM2s5=RSUM2s5+R1s5/EXP(T(1)/TAO(Is5,Js5))
	END IF
	END DO

S13:IF (ABS(RSUM1s5-G(NUMG)).LT.10.**(-6.)) THEN
	GOTO 03	
	ELSE
S14:IF (RSUM1s5.GT.G(NUMG)) THEN
	R1s5=RSUM1s5/G(NUMG)
	R2s5=(RSUM3s5-RSUM2s5/R1s5)/(RSUM3s5-RSUM2s5)	
	DO Js5=1,NN
	IF (T(NUMG)/TAO(Is5,Js5).LT.10.) THEN	
	A(Is5,Js5)=A(Is5,Js5)/R1s5
	DO WHILE (A(Is5,Js5).LT.1.)
	CHECK=1
	A(Is5,Js5)=10.*A(Is5,Js5)
	B(Is5,Js5)=B(Is5,Js5)-1
	END DO
	ELSE
 	A(Is5,Js5)=A(Is5,Js5)*R2s5
	DO WHILE (A(Is5,Js5).GE.10.)
	CHECK=1
	A(Is5,Js5)=A(Is5,Js5)/10.
	B(Is5,Js5)=B(Is5,Js5)+1
	END DO
	END IF
	END DO

	ELSE
	RSUM2s5=A(Is5,NN)*10.**B(Is5,NN)/EXP(T(NUMG)/TAO(Is5,NN))
	R1s5=(G(NUMG)-RSUM1s5)/RSUM2s5+1.
	R2s5=RSUM3s5-R1s5*A(Is5,NN)*10.**B(Is5,NN)/EXP(T(1)/TAO(Is5,NN))
	R3s5=A(Is5,NN)*10.**B(Is5,NN)/EXP(T(NUMG)/TAO(Is5,NN))
	DO WHILE (R2s5.LE.0)
	CALL RANDOM_NUMBER(RNDs5)
	IND1s5=LOG10(TAO(Is5,NN))
	IND2s5=tMAX
	TAO(Is5,NN)=10.**((IND2s5-IND1s5)*RNDs5+IND1s5)
	RSUM2s5=A(Is5,NN)*10.**B(Is5,NN)/EXP(T(NUMG)/TAO(Is5,NN))
	RSUM1s5=RSUM1s5-R3s5+RSUM2s5
	R1s5=(G(NUMG)-RSUM1s5)/RSUM2s5+1.
	R2s5=RSUM3s5-R1s5*A(Is5,NN)*10.**B(Is5,NN)/EXP(T(1)/TAO(Is5,NN))
	R3s5=A(Is5,NN)*10.**B(Is5,NN)/EXP(T(NUMG)/TAO(Is5,NN))
	END DO

 	A(Is5,NN)=A(Is5,NN)*R1s5
	DO WHILE (A(Is5,NN).GE.10.)
	CHECK=1
	A(Is5,NN)=A(Is5,NN)/10.
	B(Is5,NN)=B(Is5,NN)+1
	END DO

	END IF S14
	END IF S13
03	RESCALE2=0

	END DO S12
  	END DO S07

S08:DO Is5=1,SAMPLE		! CALCULATE THE FITNESS 
	ERR(Is5)=0.
	DO Js5=1,NUMG

	GF(Js5)=0.
	DO IIs5=1,NN
	R1s5=LOG10(T(Js5)/TAO(Is5,IIs5))
	IF ((R1s5.GT.-3.).AND.(R1s5.LT.2.)) THEN
    GF(Js5)=GF(Js5)+A(Is5,IIs5)*10.**B(Is5,IIs5)/&
	&EXP(T(Js5)/TAO(Is5,IIs5))
	ELSE
	IF (R1s5.LE.-3.) THEN
 	GF(Js5)=GF(Js5)+A(Is5,IIs5)*10.**B(Is5,IIs5)
	END IF
	END IF
	END DO
	ERR(Is5)=ERR(Is5)+ABS(G(Js5)-GF(Js5))/G(Js5)

	END DO
	END DO S08

	DO Is5=1,SAMPLE-1		  ! REORDER THE ENSEMBLE BASED ON THE FITNESS 
	MINs5=ERR(Is5)
	Ms5=Is5
	DO Js5=Is5,SAMPLE
	IF (ERR(Js5).LT.MINs5) THEN
	MINs5=ERR(Js5)
	ERR(Js5)=ERR(Is5)
	ERR(Is5)=MINs5
	Ms5=Js5
	END IF
	END DO
	IF (Is5.EQ.1) THEN
	OPT2=MINs5
	END IF
	DO Js5=1,NN
	XCHCs5=A(Is5,Js5)
	A(Is5,Js5)=A(Ms5,Js5)
	A(Ms5,Js5)=XCHCs5
	XCHs5=B(Is5,Js5)
	B(Is5,Js5)=B(Ms5,Js5)
	B(Ms5,Js5)=XCHs5
	XCHCs5=TAO(Is5,Js5)
	TAO(Is5,Js5)=TAO(Ms5,Js5)
	TAO(Ms5,Js5)=XCHCs5
	END DO
	END DO

	IF (OPT2.LT.OPT1) THEN
	OPT1=OPT2
	DO Is5=1,NN
	Ao5(Is5)=A(1,Is5)
	Bo5(Is5)=B(1,Is5)
	To5(Is5)=TAO(1,Is5)
	END DO
	END IF

	DO Is5=(SAMPLE/2+1-NELT),(SAMPLE/2)	! KEEP THE ELITES
	DO Js5=1,NN
	A(Is5,Js5)=A(3*SAMPLE/4+1-Is5,Js5)
	B(Is5,Js5)=B(3*SAMPLE/4+1-Is5,Js5)
	TAO(Is5,Js5)=TAO(3*SAMPLE/4+1-Is5,Js5)
	END DO
	END DO

S09:DO Is5=1,(SAMPLE/4-NELT/2) 				! CROSS-OVER 
	CALL RANDOM_NUMBER(RNDs5)
	IF (RNDs5.LE.PC) THEN

	CALL RANDOM_NUMBER(RNDs5)
	PT1=CEILING(RNDs5*(NN-1))
	CALL RANDOM_NUMBER(RNDs5)
	PT2=CEILING(RNDs5*(NN-1))
	IF (PT1.GT.PT2) THEN
	XCHs5=PT1
	PT1=PT2
	PT2=XCHs5
	END IF
	DO Js5=PT1,PT2
	XCHCs5=A(2*Is5-1,Js5)
	A(2*Is5-1,Js5)=A(2*Is5,Js5)
	A(2*Is5,Js5)=XCHCs5
	XCHs5=B(2*Is5-1,Js5)
	B(2*Is5-1,Js5)=B(2*Is5,Js5)
	B(2*Is5,Js5)=XCHs5
	XCHCs5=TAO(2*Is5-1,Js5)
	TAO(2*Is5-1,Js5)=TAO(2*Is5,Js5)
	TAO(2*Is5,Js5)=XCHCs5
	END DO

	END IF
	END DO S09

S10:DO Is5=1,(SAMPLE/2-NELT)				  ! MUTATION
	DO Js5=1,NN

	CALL RANDOM_NUMBER(RNDs5)
	IF (RNDs5.LE.PM) THEN
	CALL RANDOM_NUMBER(RNDs5)
	A(Is5,Js5)=RNDs5*9.+1.
	END IF

	CALL RANDOM_NUMBER(RNDs5)
	IF (RNDs5.LE.PM) THEN
 	CALL RANDOM_NUMBER(RNDs5)
	B(Is5,Js5)=FLOOR((RNDs5-1.)*3.)
	END IF
	IF ((Js5.EQ.NN).OR.(Js5.EQ.1)) THEN
	B(Is5,Js5)=-2
	END IF

	IF (FLAGi5.EQ.0) THEN
	CALL RANDOM_NUMBER(RNDs5)
	IF (RNDs5.LE.PM) THEN
	IND1s5=(tMAX-tMIN)/NN*(Js5-1)+tMIN
	IND2s5=(tMAX-tMIN)/NN*Js5+tMIN
	CALL RANDOM_NUMBER(RNDs5)
	TAO(Is5,Js5)=10.**((IND2s5-IND1s5)*RNDs5+IND1s5)
	END IF
	END IF

	END DO
	END DO	S10

	DO Is5=(SAMPLE/2)+1,SAMPLE		! SELECTION 
	DO Js5=1,NN
	CALL RANDOM_NUMBER(RNDs5)
	A(Is5,Js5)=RNDs5*9.+1.
	CALL RANDOM_NUMBER(RNDs5)
	B(Is5,Js5)=FLOOR((RNDs5-1.)*3.)
	IF ((Js5.EQ.NN).OR.(Js5.EQ.1)) THEN
	B(Is5,Js5)=-2
	END IF
	IND1s5=(tMAX-tMIN)/NN*(Js5-1)+tMIN
	IND2s5=(tMAX-tMIN)/NN*Js5+tMIN
	IF (FLAGi5.EQ.0) THEN
	CALL RANDOM_NUMBER(RNDs5)
	TAO(Is5,Js5)=10.**((IND2s5-IND1s5)*RNDs5+IND1s5)
	ELSE
	TAO(Is5,Js5)=10.**((tMAX-tMIN)/NN*(Js5-0.5)+tMIN) 
	END IF
	END DO
	END DO

	IF (MOD(Ks5,5000).EQ.0) THEN
	WRITE(*,*) Ks5,' GENERATION FINISH',OPT1
	END IF

	END DO S06

	DO Is5=1,NUMG					! CALCULATE THE FITTING
	GF(Is5)=0.
	DO Js5=1,NN
	R1s5=LOG10(T(Is5)/To5(Js5))
	IF ((R1s5.GT.-3.).AND.(R1s5.LT.2.)) THEN
    GF(Is5)=GF(Is5)+Ao5(Js5)*10.**Bo5(Js5)/EXP(T(Is5)/To5(Js5))
	ELSE
	IF (R1s5.LE.-3.) THEN
 	GF(Is5)=GF(Is5)+Ao5(Js5)*10.**Bo5(Js5)
	END IF
	END IF
	END DO
	END DO

	ERRMo5=OPT1/NUMG

 	RETURN 

	END	SUBROUTINE GEAM

!==================================================================
!      SUBROUTINE 6: CALCULATE FITTING ERROR 
!==================================================================

	SUBROUTINE CFER(WLi6,WMi6,WHi6,FERo6,PERo6)

 	USE SHARED

	REAL :: MERs6(2)
	REAL, INTENT(OUT) :: FERo6(4),PERo6(5)
	INTEGER :: Is6,Js6,SERs6(2),FLAGs6
	INTEGER, INTENT(IN) :: WLi6,WMi6,WHi6	

	SERs6=0					! THE NUMBER OF REGIONS WHOSE FITTING ERROR IS LESS THAN 0.1
	FERo6=0.				! THE AVERGAE ERROR OF DIFFERENT REGIONS
	PERo6=0.				! THE ERROR OF SPECIFIC POINTS
	MERs6=0.				! THE OVERALL ERROR

	DO Is6=1,WLi6			! THE AVERAGE FITTING ERROR FOR LOW FREQUENCY REGION
	FERo6(1)=FERo6(1)+(LOG(GGF(Is6)/GGE(Is6))+LOG(GGGF(Is6)/GGGE(Is6)))
	END DO
	FERo6(1)=FERo6(1)/2./WLi6
	IF (ABS(FERo6(1)).LT.0.1) THEN
	SERs6(1)=SERs6(1)+1
	ELSE
	MERs6(1)=MERs6(1)+ABS(FERo6(1))
	END IF	
				    
	DO Is6=WLi6+1,WMi6		! THE AVERAGE FITTING ERROR FOR INTERMEDIATE LOW REGION
	FERo6(2)=FERo6(2)+(LOG(GGF(Is6)/GGE(Is6))+LOG(GGGF(Is6)/GGGE(Is6)))
	END DO
	FERo6(2)=FERo6(2)/2./(WMi6-WLi6)
	IF (ABS(FERo6(2)).LT.0.1) THEN
	SERs6(1)=SERs6(1)+1
	ELSE
	MERs6(1)=MERs6(1)+ABS(FERo6(2))
	END IF
			    
	DO Is6=WMi6+1,WHi6		! THE AVERAGE FITTING ERROR FOR INTERMEDIATE HIGH REGION
	FERo6(3)=FERo6(3)+(LOG(GGF(Is6)/GGE(Is6))+LOG(GGGF(Is6)/GGGE(Is6)))
	END DO
	FERo6(3)=FERo6(3)/2./(WHi6-WMi6)
	IF (FLAGMR.EQ.0) THEN
	IF (ABS(FERo6(3)).LT.0.1) THEN
	SERs6(1)=SERs6(1)+1
	ELSE
	MERs6(1)=MERs6(1)+ABS(FERo6(3))
	END IF
    END IF

	IF (FLAGMR.EQ.0) THEN				
	DO Is6=WHi6+1,NUMIN		! THE AVERAGE FITTING ERROR FOR HIGH FREQUENCY REGION
	FERo6(4)=FERo6(4)+(LOG(GGF(Is6)/GGE(Is6))+LOG(GGGF(Is6)/GGGE(Is6)))
	END DO
	FERo6(4)=FERo6(4)/2./(NUMIN-WHi6)
	END IF

	PERo6(1)=LOG(GGFC1/GGC1)+LOG(GGGFC1/GGGC1)    
	PERo6(1)=PERo6(1)/2.	! MAGITUDE DIFFERNECE OF 1st CROSSOVER POINT 
	IF (ABS(PERo6(1)).LT.0.1) THEN
	SERs6(2)=SERs6(2)+1
	ELSE
	MERs6(2)=MERs6(2)+ABS(PERo6(1))
	END IF

	PERo6(2)=LOG(FQFC1/FQC1) ! FREQUENCY DIFFERNECE OF 1st CROSSOVER POINT
	IF (ABS(PERo6(2)).LT.0.1)	THEN
	SERs6(2)=SERs6(2)+1
	ELSE
	MERs6(2)=MERs6(2)+ABS(PERo6(2))
	END IF

	PERo6(3)=LOG(GGGFM/GGGM)	! MAGITUDE DIFFERNECE OF INTERMEDIATE POINT
	IF (ABS(PERo6(3)).LT.0.1)	THEN
	SERs6(2)=SERs6(2)+1
	ELSE
	MERs6(2)=MERs6(2)+ABS(PERo6(3))
	END IF

	PERo6(4)=LOG(FQFM/FQM)	! FREQUENCY DIFFERNECE OF INTERMEDIATE POINT

 	IF (FLAGMR.EQ.0) THEN
	PERo6(5)=LOG(FQFC2/FQC2)	! FREQUENCY DIFFERNECE OF 2nd CROSSOVER POINT 
	IF (ABS(PERo6(5)).LT.0.1)	THEN
	SERs6(2)=SERs6(2)+1
	ELSE
	MERs6(2)=MERs6(2)+ABS(PERo6(5))
	END IF
	END IF

	IF (SERs6(1).LT.SERR(1)) THEN
	FLAGPR=1
	SERR(1)=SERs6(1)				     
	END IF
    IF ((SERs6(1).EQ.SERR(1)).AND.(SERs6(2).LT.SERR(2))) THEN
	FLAGPR=1
	SERR(2)=SERs6(2)				 
	END IF
	IF ((SERs6(1).EQ.SERR(1)).AND.(SERs6(2).EQ.SERR(2))) THEN
	IF (MERs6(1).LT.MERR(1)) THEN
	FLAGPR=1
	MERR(1)=MERs6(1)
	END IF
	IF ((MERs6(1).EQ.MERR(1)).AND.(MERs6(2).LT.MERR(2))) THEN
	FLAGPR=1
	MERR(2)=MERs6(2)
	END IF
	END IF

 	IF (FLAGMR.EQ.1) THEN
	Js6=1
	ELSE
	Js6=0
	END IF

	FLAGs6=1
	DO Is6=1,3-Js6
	IF (ABS(FERo6(Is6)).GE.0.1) THEN
	FLAGs6=0
	GOTO 04
	END IF
	END DO
	DO Is6=1,5-Js6
	IF (ABS(PERo6(Is6)).GE.0.1) THEN
	FLAGs6=0
	GOTO 04
	END IF
	END DO
	IF (ABS(VERR).GE.0.1) THEN
	FLAGs6=0
	GOTO 04
	END IF

04	IF (FLAGs6.EQ.1) THEN
	IF (FLAGN.EQ.1) THEN	
	FLAGD=1
	ELSE
	FLAGN=1
	FLAGIT=0
    WRITE(*,*) 'INCREASE ENSEMBLE SIZE'
	WRITE(24,*) 'INCREASE ENSEMBLE SIZE'
	END IF
	END IF

 	RETURN 

	END	SUBROUTINE CFER

!==================================================================
!      SUBROUTINE 7: CALCULATE FITTING ERROR 
!==================================================================

	SUBROUTINE PRDF(G0i7,RATIOi7,ZEi7,Lpi7,G0o7,RATIOo7,ZEo7,Lpo7,FLAGo7)

 	USE SHARED

	REAL, INTENT(IN) :: G0i7,RATIOi7,ZEi7,Lpi7
	REAL, INTENT(OUT) :: G0o7,RATIOo7,ZEo7,Lpo7
	INTEGER, INTENT(OUT) :: FLAGo7

	GERR=0.	          ! THE FITTING DEVIATION FOR Z AND RATIO
	FLAGo7=1

	ZEo7=ZEi7*(GGM/GGFM*GGGFM/GGGM)**(1.33*RELAX)
    IF (ZEo7.GT.ZEMA) THEN
	ZEo7=ZEMA
	END IF
	IF (ZEo7.LT.ZEMI) THEN
	ZEo7=ZEMI
	END IF
	ZEo7=ZEo7**RELAX*ZEi7**(1.-RELAX)

	GERR(1)=(GGGFM/GGFM-GGGM/GGM)/(GGGM/GGM)
	GERR(2)=(FQFC1-FQC1)/FQC1

	IF ((ABS(GERR(1)).LT.0.1).AND.(ABS(GERR(2)).LT.0.1)) THEN
	FLAGo7=0
	END IF
	IF (II.GT.6) THEN
	FLAGo7=0
	END IF

S11:IF (FLAGo7.EQ.0) THEN
    IF (SLP.EQ.1) THEN
	IF (FLAGMR.EQ.0) THEN
	Lpo7=Lpi7*(FQFC2/FQC2)**(0.33*RELAX)
	ELSE
	Lpo7=Lpi7*EXP(-0.8*FRLP*RELAX)
	END IF
   
    IF (Lpo7.GT.LpMA) THEN
	Lpo7=LpMA
	END IF
	IF (Lpo7.LT.LpMI) THEN
	Lpo7=LpMI
	END IF
	Lpo7=Lpo7**RELAX*Lpi7**(1.-RELAX)

	ELSE
	Lpo7=Lpi7
	END IF 
	END IF S11
 
	RATIOo7=RATIOi7*(FQFC1/FQC1*(Lpi7*ZEi7/Lpo7/ZEo7)**3.)**(1.5*RELAX)
    IF (RATIOo7.GT.RATIOMA) THEN
	RATIOo7=RATIOMA
	END IF
	IF (RATIOo7.LT.RATIOMI) THEN
	RATIOo7=RATIOMI
	END IF
	RATIOo7=RATIOo7**RELAX*RATIOi7**(1.-RELAX)

	IF (FLAGo7.EQ.0) THEN
	G0o7=G0i7*(GGGC1/GGGFC1)**RELAX
    IF (G0o7.GT.G0MA) THEN
	G0o7=G0MA
	END IF
	IF (G0o7.LT.G0MI) THEN
	G0o7=G0MI
	END IF
	G0o7=G0o7**RELAX*(V0/t0)**(1.-RELAX)
	ELSE
	G0o7=G0i7
	END IF

	II=II+1

 	RETURN 

	END	SUBROUTINE PRDF
